## 计算机图形学----圆和椭圆的扫描转换算法

圆是中心对称的特殊图形，所以可以将圆八等分，则只须对八分之一圆孤求解，其它圆孤可以由对称变换得到，我们求的八分之一圆孤为(0, R) -(R√2,R√2)，可知最大位移方向是x方向，x0 = 0, y0 = R，每次对x自增，然后判断y是否减1，直到x >= y为止(从点(0, R)到圆的八分之一处就有这种情况)。



### 中点扫描转换算法

 - 误差量由d =Ｆ(x, y) = x^2 + y^2 - R^2给出。

 - 递推关系

    - 若当前d = F(x + 1, y - 0.5) > 0，则y须减1，则下一d值为d = F(x + 2, y - 1.5) = (x + 2)^2 + (y - 1.5)^2 - R^2 = (x + 1)^2 + (x - 0.5)^2 - R^2 + 2x + 3 - 2y + 2 = d + 2x - 2y + 5。
      	- 此时增加量为：2（x-y）+5
    - 若当前d = F(x + 1, y - 0.5) < 0，则y不变，只有x增1，则下一d值为d = F(x + 2, y - 0.5) = d + 2x + 3。
      	- 此时增加量为： 2x+3

- d的初值：d0 = F(1, R - 0.5) = 1.25 - R

- 算法 ： 中点画圆算法

  ```
  void MidpointCircle(int R)
  {
  	int x,y;
  	double d;
  	x=0;
  	y=R;
  	d=1.25-R;
  	SetPixel(x,y);
  	while(x<y)
  	{
  		if(d<0)
  		{
  			d+=2*x+3;
  			x++;
  		}
  		else
  		{
  			d+=2*(x-y)+5;
  			x++;
  			y--;
  		}
  		SetPixel(x,y);
  	}
  }
  ```

  

### Bresenham画圆算法

- 判别量： p = dH - dD

- 递推关系
  - pi+1-pi = 2 (yi+1^2 - yi^2 - yi+1 + yi) + 4xi +6
  - pi>=0 选D
    - yi+1=yi -1 
    - 增加量 4（xi - yi ）+ 10
  - pi <= 0 选H
    - yi+1 = yi
    - 增加量 4 * xi +6
  
- 算法：

  - ```
    void BresenhamCircle(int R)
    {
    	int x,y,R;
    	x=0;
    	y=R;
    	p=3-2*R;
    	for(;x<=y;x++)
    	{
    		SetPixel(x,y);
    		if(p>=0)
    		{
    			p+=4*(x-y)+10;
    			y--;
    		}
    		else
    		{
    			p+=4*x+6;
    		}
    	}
    }
    ```

    

### 椭圆扫描转换算法

​	