###  OOP09 内存管理
#### C++程序占用的内存区分区
- 全局、静态数据区：存储全局变量及静态变量
- 常量数据区：存储程序中的常量字符串等
- 代码区：存储程序的代码，即程序中各个函数的代码
- 栈区：存储局部自动变量，如函数中的变量等
- 堆区：存储动态产生的变量
#### 静态内存管理
- 由编译器决定内存分配的时机、空间以及内存释放
- 单个对象
#### 静态内存管理的不足
- 变量的生存期和作用域不够灵活
	例：Time  time1(10,20,30);
- 编译期间确定所使用的内存大小
	例：Time  times[50];   数组的大小必须是常量
#### 静态内存管理的优势
- 变量的生存期结束时自动释放

#### 动态内存管理
- 由程序员根据需要来确定内存分配的时机、空间以及内存释放。一般在程序运行时而不是在编译时分配内存
- 在堆中动态分配存储空间，可以采用指针和new运算符分配内存，用delete运算符释放new申请的内存
- new运算符的一般格式为
	<指针变量名>=new <类型>;
    或 <指针变量名>=new <类型>(<初值>);
    或 <指针变量名>=new <类型>[<元素个数>]; //动态数组
	使用new创建数组时，C++98/03不能为该数组指定初始值，C++11中可以使用列表初始化方法为该数组指定初始值。
- delete运算符的一般格式为
	delete <指针变量名>
	或 delete[] <指针变量名>
	其中，第2种格式用于释放指针指向的连续存储空间，即释放数组占用的空间，使用时应注意：
	(1)必须用于由new返回的指针
	(2)对一个指针只能使用一次delete操作
	(3)指针变量名前只用一对方括号，不管所删除的数组的维数，忽略方括号内的任何数字
#### 关于动态内存管理的注意
- 用delete释放一块不是由new申请的内存，结果是不可预测的
- new与delete一定要配对使用，避免内存泄露
- 如果一块内存被delete后，再对它delete或解引用，结果也是不可预测的，很可能导致程序崩溃
- delete一个空(NULL)指针是安全的，没有任何害处
- 类成员类型的operator new/delete函数必须为静态函数，因此它们不能为虚函数(virtual function)，同时必须遵守public， protected，private的访问权限控制
