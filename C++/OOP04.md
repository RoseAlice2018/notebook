## OOP04
### 指针的使用
- ‘*’ 解引用操作符 （dereference operator），可以理解为取变量中存储的地址所指向的内容，也称为间接（引用）操作符。
- ‘&’ 取地址/引用操作符（Address or reference operator）可以理解为取变量的地址。
#### 指针的算术运算
1.只有加法和减法。
2.给指针加1时，实际是让指针指向下一个与它的数据类型相同的元素。因此，它所指的数据类型的长度字节数就会被加到指针的数值上。
#### void* 指针
1.可以保存任何类型对象的地址。
2.表明该指针与一地址值相关，但不清楚存储在此地址上的对象的类型，主要用于函数参数和返回值。
3.不允许使用void* 指针操纵它所指向的对象。
### 指针数组和指向数组的指针
1. 如果一个数组的每个元素都是指针，称其为指针数组。指针数组的每个元素都必须是同一类型的指针。
	int *pa[2];
	
2. ```
   int a[4]={1,2,3,4};
   pa=&a;// pa是一个数组指针
   cout<<(*pa)[3];
   ```
3. C++ 数组名字是一个指针常量，指向数组的第一个元素。
4. 一维数组的指针表示法
```
int a[4];// a[i] || *(a+i);
```
二维数组指针表示法
```
int b[2][5];
b[i][j] or *(*(b+i)+j) or *(b[i]+j) or (*(b+i))[j] or (&b[0][0]+5*i+j);
```

### 引用 
- 引用定义的同时必须使用相同类型的对象进行初始化
- 引用初始化之后，只要该引用存在，它就保持绑定到初始化指定的对象，不可能将它绑定到另一个对象。

### 右值引用 
- 早期直观定义： 左值是一个可以出现在赋值运算符的左边或者右边的表达式，而右值则是只能出现在赋值运算符右边的表达式。
- 另一种定义：左值是一个指向某内存空间的表达式，并且可以用&操作符获得该内存空间的地址。右值就是非左值的表达式，例如临时量、文字常量，临时量指的是非引用返回的函数返回值、表达式等。
-右值引用就是对一个右值进行引用的类型。一般可描述为T &&(中间不能有空格)，意为“到T的右值引用”类型
右值引用在定义时必须同时初始化
右值引用不能绑定到左值，除非用std::move()将左值强制转换为右值
```
int a;
int& lv1 = a;  //左值引用
int&& rv1 = a; //编译失败
int& lv2 = int();  //编译失败
int&& rv2 = int(); //编译通过
int&& rv3 = std::move(a);//ok
```
```
int &&i = 1;
int b = 2;
i = b;   //修改所引用的右值
cout << i << endl; //输出2
int && temp = i; //编译失败
// i是一个右值引用变量，变量是左值，故temp引用左值i是非法的
```
#### 不变量
1.  文字常量，字面量
2.  宏定义
3.  命名常量 const常量，枚举常量
4.  const与指针
5.  const与引用

#### 常量指针
- 常量指针，即指向const对象的指针。如果指针指向const对象，则不允许指针来改变其所指的const对象的值，此时该指针也必须具有const特性

  ```
  const <类型> *<指针名>;
   例：const double *cptr;
   这里，cptr 是一个指向 double 类型const对象的指针，const限定了cptr指针所指向的对象类型，而并非cptr本身。也就是说，cptr本身并不是const，在定义时不需要对它进行初始化，如果需要的话，允许给cptr重新赋值，使其指向另一个const对象；但不能通过cptr修改其所指对象的值
  
  ```

  ```
  常量指针例子
      const double *cptr;	         //常量指针，不必初始化
      const double pi = 3.14;              //常量
      cptr = &pi;                                 //常量指针赋值
  	*cptr = 3.14159;                        //错误
  	 double *ptr = &pi;	         //错误
  
  允许把非const对象的地址赋给指向const对象的指针
      double pi = 3.14;                       //非const对象
      cptr = &pi;                                //正确
      *cptr = 3.14159;                       //错误
  
  ```

  ```
  不能使用常量指针修改其所指对象，然而如果该指针指向的是一个非const对象，可以直接给该对象赋值或间接地利用普通的非const指针修改其值
      例：double *ptr = &dval;
              *ptr = 2.72;
              cout << *cptr;      //输出为2.72
  在实际的程序中，常量指针常用作函数的形参。将形参定义为常量指针，以此确保传递给函数的实际对象在函数中不会被修改
  
  ```

### 指针常量
- 指针常量，即指针本身的值不能改变的指针，或称常指针、const指针
格式
    <类型> *const <指针名>=<初始化式>;
    例：double pi = 3.14;
            double *const ptrc = &pi;
    这里，ptrc是指向double型对象的const指针
  
- ```
指针常量必须在定义的同时初始化
      例：double *const ptrc;        //错误
  指针常量本身的值不能修改
      例：ptrc = ptrc;                    //错误
  指针本身是const并没有说明是否能使用该指针修改它所指向对象的值。指针所指对象的值能否修改完全取决于该对象的类型
      例：*ptrc = 3.14159;           //正确
  
  ```
  
  ```
  常量指针常量，即指向const对象的const指针
  格式
      const <类型> *const <指针名>=<初始化式>;
      例：const double pi = 3.14;
              const double *const cptrc = &pi;
      这里，cptrc是指向double型const对象的const指针。定义的同时必须初始化，且既不能修改cptrc所指向对象的值，也不能修改该指针本身的值
  
  ```
### const引用

```
如果在声明引用时用const修饰，则称该引用为const引用，const引用是指向const对象的引用
格式
    const  <类型> &<引用名>=<对象>;
    例：const int ival = 1024;
            const int &refval = ival;     // ok
            refval = 2048;                     // error
            int &ref2 = ival;                  // error，非const引用

```

```
const引用可以初始化为不同但相关类型的对象或者初始化为右值，如字面值常量
    例：int i = 42;
            const int &r = 42;           // ok
            const int &r2 = r + i;      // ok
            double dval = 3.14;
            const int &ri = dval;       // ok
    注：同样的初始化对于非 const 引用却是不合法的，会导致编译时错误

```

```
在实际的程序中，const引用常用作函数的形参。将形参定义为const引用，以此确保传递给函数的实际对象在函数中不会被修改
    例：
     double d(9.5);	display(d);
	 void display(const double& r)	   //const引用做形参
	 {
		   cout<<r<<endl;	  //函数中不能更改r所引用的对象
		   r=5.5;		               //编译错误
	 }

```

