## OOP07  类与对象

### 类定义
1. 对象是问题域中一些事物的抽象，是一些属性、操作和方法的封装体，类是对象特征的描述，一个类刻画了一组具有相同特征的对象，类是对同类对象的抽象
2. 从实现角度来说，类是某种自定义数据类型，对象是该类型的变量
3. 与结构体类似，类由若干个成员组成。类可以没有成员，也可以定义多个成员，成员可以是数据(称为数据成员、成员变量)、函数(称为成员函数)或类型
与结构体一样，先定义类型再声明变量（对象）

#### 类定义的一般格式

```
class <类名>
{
<访问控制符>:
    <成员函数的声明>
<访问控制符>:
    <数据成员的声明>
};
<成员函数的实现>

```
#### 成员函数

```
如果成员函数在类体外实现，则需要使用作用域运算符“::”，用它来标识某个成员函数是属于哪个类的，其定义格式如下：
    <返回类型> <类名>::<成员函数名>(<形参表>)
    {
        <函数体>
    }

```
#### 访问权限控制
- 访问权限控制符包括public、private和protected ，对应的成员分别称为公有成员、私有成员和保护成员
- 三种访问权限的成员与出现的先后顺序无关，并且允许多次出现，但一个成员只能具有一种访问权限属性
- 一般来说，建议将类的public成员放在类体的前面，将 protected、private成员放在类体的后面
- 类成员的缺省访问权限(未显式指定访问权限控制符时)为private
- 公有成员在程序的任何地方都可以被访问，是类的对外接口。而且在类外只能访问类的公有成员。所谓类外指的是普通函数或其他类的成员函数。一般来说，成员函数的访问权限设为public，类外通过公有成员来操纵该类对象的操作
- 私有成员只能被本类中的成员函数和友元访问，而不能被类外调用。一般来说，数据成员的访问权限设为private或protected(如果有继承关系时)
- 保护成员具有双重性，对其派生类而言，保护成员如同公有成员；对类外来说则表现得像私有成员。一般来说，程序中有类继承时，可以将部分类成员定义为保护成员，以便派生类访问，同时，对类外又实现了信息隐藏。关于保护成员将在介绍派生类以及继承的概念时进一步讨论

#### 成员访问
- 类外访问类成员方法：
（1）通过对象名和成员访问运算符访问对象中的成员
          <对象名>.<公有成员>
（2）通过指向对象的指针变量访问对象中的成员
          <对象指针名> -> <公有成员>
（3）通过对象的引用访问对象中的成员
          <对象引用名>.<公有成员>
- **根据变量定义，全局变量和静态变量在定义(分配空间)时，将位模式清零，局部变量在定义时，分配的内存空间保持原样，故为随机数**

#### 对象的存储空间
- 由此说明，各对象空间中只有数据成员，而无成员函数的空间。成员函数只存储一份，由各对象共享
- 没有任何数据成员的类对象占用一个字节的空间。编译器会给一个空类隐含的添加一个字节，使空类在实例化后在内存中占有独一无二的地址
- 静态数据成员存储在内存的全局、静态数据区中，不占用类对象的存储空间
- 其它参照结构体类型对齐原则

### 对象的构造和析构
- C++中对象的初始化和清理工作，分别由两个特殊的成员函数来完成，即构造函数和析构函数
#### 构造函数
- 构造函数的功能是在定义对象时被编译系统自动调用来创建对象并初始化对象
- 构造函数的声明格式
     <类名>(<参数表>);
- 构造函数的定义格式
     [<类名>::]<类名>(<参数表>)[:初始化列表]    {    <函数体>     }
     构造函数与类同名，并且构造函数没有函数返回类型。一般被定义为公有成员，只能被调用一次。可以带参数，也可以不带参数
##### 无参构造函数
- 事实上，如果在类中没有显式定义构造函数，那么编译器就会为该类自动生成一个默认形式的构造函数，这个构造函数的功能仅用于创建对象，其形式如下：
	<类名>::<类名>( )  {     } 
- 编译器自动生成的默认形式的构造函数是无参的(形参表为空)，函数体是空的，访问权限是public的，它只是负责创建对象，但不能给数据成员赋初值
- 只要在类中显式定义了构造函数，无论是无参还是带参构造函数，编译器就不会为该类生成默认形式的构造函数
##### 带参构造函数
- 带参构造函数的一般格式为：
     <构造函数名>(<类型1> <形参1>，<类型2> <形参2>，…);
- 带参定义对象的格式为：
	<类名> <对象名>(<实参1>，<实参2>，…);
- 一般地，函数的实参与形参结合是通过函数调用语句来实现的。由于构造函数是在对象定义时被系统自动调用，因此带参构造函数的形参对应的实参必须在定义对象时给出

##### 构造函数的注意
- 构造函数是成员函数，可以在类体内或类体外定义
- 构造函数的名字必须与类名同名
- 构造函数不能指定函数返回类型，甚至void也不行
- 构造函数可以没有参数，也可以有参数，允许重载，即可以定义参数不同的多个构造函数
- 每个类至少有一个构造函数(可能是编译器自动生成的)，且应是公有成员。没有公有构造函数，无法在类外定义对象
- 在定义类对象时，构造函数由系统自动调用

##### 构造函数初始化列表
- 对象的初始化可以在构造函数的函数体内完成，也可以采用构造函数初始化列表完成
初始化列表位于构造函数参数表之后(用:作为函数参数表和初始化表的分隔符)、函数体之前
     Time::Time(int nh, int nm, int ns):Hour(nh),Minute(nm),Second(ns){ }
-  初始化列表里的初始发生在函数体内的任何代码被执行之前对内置类型和指针类型的数据成员，在构造函数体内还是初始化列表初始化没有差别，对自定义类型的数据成员，为了避免重复初始化，推荐使用构造函数初始化列表初始化
- **下面情况必须采用构造函数初始化列表初始化 **
  （1）成员类型是没有缺省构造函数的类。若没有显式提供构造函数，则编译器隐式使用成员所属类的缺省构造函数，若该类没有缺省构造函数，则编译器编译失败
  （2）const成员或引用类型的成员。因为这两种成员要在声明后马上初始化，而在构造函数中，做的是对它们的赋值，因此，必须在构造函数初始化列表初始化
- 初始化列表的成员初始化顺序是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序

#### 析构函数
- 析构函数的功能是在对象的生存期结束时，由编译器自动调用来完成一些清理工作。析构函数调用完成之后，对象也就消失了，相应的内存空间也被释放
- 析构函数的声明格式
	~<类名>( );
- 析构函数的定义格式
     [<类名>::]~<类名>( )     {   <函数体>    }
     析构函数与类同名，并且析构函数没有函数返回类型。一般被定义为公有成员，只允许被调用一次。不带参数，不能重载
##### 析构函数的注意
- 析构函数是成员函数，可以在类体内或类体外定义
- 析构函数的名字必须与类名同名
- 析构函数不能指定函数返回类型，甚至void也不行
- 析构函数没有参数，不允许重载
- 每个类至少有一个析构函数，且应是公有成员。如果类中没有显式定义析构函数，则编译器自动生成一个默认形式的析构函数(函数体为空)，作为该类的公有成员析构函数在对象生存期结束时由编译器自动调用

#### 构造函数和析构函数的调用顺序
- 一般情况下，调用构造函数与声明对象的顺序相同，而调用析构函数的次序正好与创建对象的顺序相反
#### 构造函数和析构函数的调用时机
- 在全局范围内定义的对象(即在所有函数之外定义的对象)，它的构造函数在文件中所有函数(包括main函数)执行之前调用。如果一个程序中有多个文件，而不同文件中都定义了全局对象，则这些对象的构造函数的执行顺序是不确定的。当main函数执行完毕或调用exit函数时即程序终止时调用析构函数
- 如果定义的是局部自动对象，则在建立对象时调用其构造函数。如果函数被多次调用，则在每次建立对象时都要调用构造函数。在函数调用结束、对象释放时先调用析构函数
- 如果在函数中定义静态(static)局部对象，则在程序第一次调用此函数建立对象时调用构造函数一次，在调用结束时对象也不释放，因此也不调用析构函数，只在main函数结束或调用exit函数即程序终止时，才调用析构函数

### 对象的拷贝和赋值
#### 对象拷贝
- 对象拷贝是指用一个现有的对象构造一个新的对象
- 对象拷贝的格式
    <类名> <对象2>(<对象1>);
    或  <类名> <对象2>=<对象1>;
    用<对象1>拷贝<对象2>，<对象1>是一个已经存在的对象
对象拷贝是系统通过自动调用拷贝构造函数来实现的

#### 拷贝构造函数
- 拷贝构造函数的声明格式
    <类名>(const <类名>& [<对象名>]);
- 拷贝构造函数的定义格式
    [<类名>::]<类名>(const <类名>& <对象名>)[:初始化列表]
    {    <函数体>     }
    拷贝构造函数与类同名，并且拷贝构造函数没有函数返回类型。一般被定义为公有成员，只能被调用一次。参数是所属类的const对象引用
- 如果没有显式定义拷贝构造函数，编译系统就会自动生成一个公有的默认形式的拷贝构造函数，其功能是创建新对象，把现有对象的每个非静态数据成员的值都复制到新创建的对象中
- 默认形式的拷贝构造函数
    <类名>::<类名>(const <类名>& <对象名>)
    {
          ……
    }
##### 拷贝构造函数的调用时机
- 程序中需要新建立一个对象，并用另一个同类的对象对它初始化，例Time time2=time1; Time time2(time1);
- 当函数的参数为类的对象时，在调用函数时需要将实参对象传递给形参
    void fun(Time atime) { … }  //形参是类的对象
    int main( )
    {   Time time1(12,15,18);      fun(time1); 
         return 0;
    }
- 当函数的返回值是类的对象，在函数调用完毕将返回值带回函数调用处时
    Time fun2( )    {    Time t1(10,20,30);    return t1;  }
    int main( )
    {
        Time t2;
        t2=fun2( );        //调用拷贝构造函数将对象t1复制到临时
                                  //对象中，并将临时对象的值赋给对象t2
        return 0;
    }
##### 何时要显示定义拷贝构造函数
- 在默认形式的拷贝构造函数中，拷贝的策略是逐个成员依次拷贝（浅拷贝），但是，一个类可能会拥有资源（如堆内存、文件句柄、设备句柄），这时就出现了两个对象拥有同一个资源的情况，当对象析构时，将经历两次资源返还，但只有一个资源，第二次返还时已无资源，从而导致程序异常
- 一般地，如果类需要析构函数来析构资源时，则类就需要显式定义一个拷贝构造函数来进行深拷贝
##### 浅拷贝
- 用一个对象初始化另一个对象时，只拷贝了数据成员，并没有拷贝资源，使得两个对象同时指向了同一资源的拷贝方式称为浅拷贝
##### 深拷贝
- 如果一个对象在创建时分配了资源，那么必须显式定义拷贝构造函数。这种不仅拷贝成员，也拷贝资源的拷贝方式称为深拷贝
##### 拷贝构造函数的注意
- 拷贝构造函数是成员函数，可以在类体内或类体外定义
- 拷贝构造函数的名字必须与类名同名
- 拷贝构造函数不能指定函数返回类型，甚至void也不行
- 拷贝构造函数不允许重载
- 每个类都有一个拷贝构造函数，且应是公有成员。如果类中没有显式定义拷贝构造函数，则-编译器自动生成一个默认形式的拷贝构造函数(浅拷贝)，作为该类的公有成员
- 拷贝构造函数在对象拷贝时由编译器自动调用
#### 对象赋值
- 对象赋值与对象拷贝是有区别的
- 对象赋值是指用一个现有的对象修改一个已存在对象
- 对象赋值的格式
    <对象名1> = <对象名2>;  
    <对象名1> = <类名>(<参数表>);     //创建一个无名对象 
    <对象名1>和<对象名2>都代表一个已经存在的对象
- 对象赋值可以多次，对象拷贝只能一次，在创建对象时完成
- 对象赋值是系统通过自动调用赋值函数来实现的
#### 赋值函数
- 赋值函数的声明格式
    <类名> & operator=([const] <类名>& [<对象名>]);
- 赋值函数的定义格式
    <类名> &[<类名>::]operator=([const] <类名>& <对象名>)
    {    <函数体>     }
    赋值函数也是赋值运算符重载函数。赋值函数的返回类型是所属类的对象引用，参数是所属类的const对象引用。一般被定义为公有成员。
- 如果没有显式定义赋值函数，编译系统就会自动生成一个公有的默认形式的赋值函数，其功能是把现有对象的每个非静态数据成员的值都赋值给已存在对象的对应数据成员
- 默认形式的赋值函数
    <类名> &<类名>::operator=(const <类名>& <对象名>)
    {
          ……
    }
#### 赋值函数的注意
- 赋值函数是成员函数，可以在类体内或类体外定义
- 赋值函数的名字是operator=
- 赋值函数的返回类型是所属类的对象引用
- 赋值函数允许重载
- 每个类都有一个赋值函数，且应是公有成员。如果类中没有显式定义赋值函数，则编译器自动生成一个默认形式的赋值函数(浅赋值)，作为该类的公有成员
- 一般地，需要深拷贝时，也需要深赋值
- 赋值函数在对象赋值时由编译器自动调用

#### this指针
- this指针是一个特殊的指针形参，它隐含于每一个非静态成员函数中，也就是说，每个非静态成员函数都有一个this指针形参，被初始化指向调用该函数的对象
- 在实际编程时成员函数的声明中并没有包含这个形参。编译系统会把this指针加入到非静态成员函数的形参表中
- 当一个对象调用成员函数时，编译系统先将对象的地址作为实参传递给this指针形参，然后调用成员函数。每次成员函数存取数据成员时，都隐含使用this指针，通常不显式地使用this指针来调用数据成员
#### this指针的注意
- this是一个预定义的指针变量名
- this指针是一个隐含的形参，位于非静态成员函数形参表中第一个形参位置处，其作用域和生存期与其它形参相同
- this指针是一个const指针，初始化后不能修改，因此，在其所属成员函数内不能对其赋值
- this指针被初始化指向调用其所属函数的对象，在其所属成员函数内通常使用*this来标识调用该成员函数的当前对象
- 静态成员函数形参表中没有this指针形参，因此，静态成员函数内不能直接访问this指针
####  静态成员
- 静态成员是C++提供的解决同一个类的不同对象之间数据和函数共享问题的机制
- 静态成员是类的所有对象共享的成员，而不是某个对象的成员。静态成员分为静态数据成员和静态成员函数
#### 静态数据成员定义格式
- 静态数据成员必须进行显式初始化(定义)
- 静态数据成员不能在任何函数内分配空间和初始化
- 静态数据成员最好在类成员函数的实现源文件的开始部分进行初始化
- 静态数据成员定义格式
	<数据类型> <类名>::<静态数据成员名>=<值>;
    静态数据成员定义时不要加static关键字，否则错误

```
//student.cpp
#include "student.h"
#include <iostream>
using namespace std;
int Student::total=0;	//在类的实现前分配空间和初始化
Student::Student()
{
	id = 0; score = 0;
	name = new char[1];
	strcpy(name,"");
	total++;
}
Student::Student(int pid,char * pname,float s)
{
	id = pid; score = s;
	name = new char[strlen(pname)+1];
	strcpy(name,pname);
	total++;
}
/student.cpp
Student::Student(const Student& init)
{
	id = init.id;
	name = new char[strlen(init.name)+1];
	strcpy(name,init.name);
	score = init.score;
	total++;
}
void Student::Display()
{
	cout << "id:" << id << endl;
	cout << "name:" << name << endl;
	cout << "score:" << score << endl;
}
Student::~Student()
{
	delete[] name;
	total--;
}

```

#### 静态数据成员的注意
- 静态数据成员的类型可以是其所属类，而非静态数据成员只能被声明为该类的对象的指针或引用

- ```
  class A
       {
       public:
  	     …
       private:
  	     static A obj1;		//正确
  	     A* obj2;		//正确
  	     A obj3;		//错误
       };
  
  ```

- 静态数据成员可以被作为类成员函数的默认实参，而非静态数据成员不能

- ```
  extern int var;
      class B
      {
      public:
  	    int fun1(int v1=var);                 //错误
  	    int fun2(int v2=stcvar);	        //正确
      private:
  	    int var;
  	    static int stcvar;	                      //静态数据成员
      };
  
  ```
#### 静态成员函数

```

```
- 面向对象方法中还有“类方法”的概念。如果某个方法为整个类所共有，不属于任何一个具体对象，则采用static关键字来声明为静态成员函数
- 和静态数据成员一样，静态成员函数是与类相关的，是类的一种行为，而不是与类的实例对象相关
- 静态成员函数形参表中没有this指针形参，因此，静态成员函数内不能直接访问this指针

  
#### 静态成员函数的定义
- 静态成员函数可以在类体内实现，也可以在类体外实现。在类体外实现时不要加static关键字，否则错误

- ```
  class A
      {    public:   static void fun(A a);
            private:  int x;
      };
      void A::fun(A a)               //正确
      {	   /* 略 */     }
      static void A::fun(A a)     //错误
      {	   /* 略 */     }
  
  ```

  
#### 静态成员函数的注意
- 静态成员函数可以直接访问该类的静态成员，但不能直接访问类中的非静态成员，必须通过参数传递方式得到对象，然后通过对象来访问非静态成员

- ```
  class A
      {    public:   static void fun(A a);
            private:  int x;
      };
      void A::fun(A a)
      {	   cout << x;		//错误
            cout << a.x;		//正确
      }
  
  ```

#### 静态成员的访问
- 类内非静态成员函数可以直接访问非静态成员、静态成员；静态成员函数可以直接访问静态成员，通过对象访问非静态成员
- 类外访问静态成员受成员访问权限的控制，可以有2种方法：
  （1）采用类外访问非静态成员的方法
            通过对象名、对象指针、对象引用访问公有静态成员
  （2）采用类名加作用域限定符的方法
             <类名>::<公有静态成员>
#### 静态成员和全局对象的区别
- 静态成员的名字是在类的作用域中，因此可以避免与其他类的成员或全局对象名字冲突
- 可以实施封装。静态成员可以是私有成员，而全局对象不可以
- 通过阅读程序容易看出静态成员是与特定类关联的，可以清晰地显示程序员的意图

#### 常成员
- 类的数据成员和成员函数可以声明为const，分别称为常数据成员和常成员函数	

- 常数据成员只能通过构造函数的初始化列表进行初始化，不能被赋值或更改

- ```
  const int Hour;		//非静态数据成员
  	Time::Time(int h):Hour(h){}	//正确
  	Time::Time(int h){Hour=h;}	//错误
  ```
##### 常成员函数
- 常成员函数可以引用本类的数据成员，但不能修改
- 常成员函数的声明格式为
	<返回类型> <函数名>(<形参表>) const;
	例：void ShowTime() const;
- 常成员函数的定义格式为
	<返回类型> [<类名>::]<函数名>(<形参表>) const;
	例：void Time::ShowTime() const
           {   /* 略 */   }
##### 常成员函数的注意
- const是函数类型的一部分，在声明函数和定义函数时都要有const关键字，调用时不必加
- 常成员函数不能修改本类的数据成员，也不能调用类中非const成员函数，但可以调用静态成员函数
- 静态成员函数不能被声明为const
- 如果将对象声明为常对象，则通过该常对象只能调用它的常成员函数，这是常对象唯一的对外接口方式
- const成员函数与相同的非const成员函数是重载的

  
#### 对象成员
- 用已存在类的对象作为另一个类的成员，我们称之为对象成员或子对象
- 对象成员可以描述整体/部分的关系。例如：可以把窗口作为整体对象，把标题栏、菜单栏、客户区和状态栏作为部分对象，描述窗口含有标题栏、菜单栏、客户区和状态栏这种关系；可以把人体作为整体对象，把大脑、四肢和躯干作为部分对象，描述人体由大脑、四肢和躯干组成这种关系
- 整体/部分关系有两类，聚合与组合，前者松散灵活，后者紧密固定。对象成员描述的是组合关系
#### 对象成员的声明
- 声明对象成员时，其所属类必须在当前类之前已定义

- ```
  class A
  	{
          int i;
  	};
  	class B
  	{
          int j;
          A a;  //对象成员
  	};
  
  ```

#### 对象成员的构造和析构顺序
- 类中出现对象成员时，创建本类对象既要对本类的数据成员进行初始化，又要对对象成员进行初始化。这时，本类构造函数会先调用对象成员的构造函数，等全部对象成员初始化完成之后，才对本类的其他数据成员进行初始化。析构顺序刚好相反
- 类中出现多个对象成员时，对象成员的初始化顺序按照，对象成员的声明顺序进行。对象成员的析构顺序刚好相反

#### 对象数组成员
- 一个类的对象可以作为另一个类的成员，那么对象数组同样可以作为另一个类的成员
- 对象数组成员的初始化过程同对象成员一样，不同的地方是，对象数组成员一般采用隐式初始化方法，因此，要求所属类必须提供缺省构造函数
