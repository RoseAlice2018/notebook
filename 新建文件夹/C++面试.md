# C++面试

## 1. 说一下多态的理解。   

- 首先呢，多态就是一个接口的多种实现，多态可以分为两个部分。一个是静态多态，一个是动态多态。静态多态在编译器，动态多态在运行期。
- 静态多态呢，有比如说函数重载，运算符重载，泛型编程这样的手段，为什么叫静态呢，是因为在编译器就可以确定下来。
- 动态多态，主要就是虚函数，具体的接口引用在运行期确定。
- 静态多态和动态多态的区别就是，何时将函数实现和函数调用关联起来，是在编译期还是在运行期，也就是函数地址是早绑定还是晚绑定。静态多态是指编译器可以确定函数调用的地址，并且产生代码，而动态多态是指的函数调用不在编译器确定在运行，而是在运行时确定函数调用地址是晚绑定。
- 封装和继承可以使得代码重用，而多态的目的则是使得接口重用。静态多态指的是对于同一个接口，你传入不同的函数签名，给你匹配不同的实现，从，而动态多态，则是根据你传过来的对象，来选择不同的实现。

## 2. 析构函数是否需要是虚函数。（*）

- 如果你的类已经是final了，不希望再被继承，使用多态的性质，没有虚函数，那么就不需要使用虚函数。
- 相反的，如果你的base class ，有虚函数（除了析构函数外），那么就需要使得虚构函数是虚函数。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

## 3. static关键字有哪些用法。

## 4. inline函数

- inline函数是由inline关键字定义的，引入inline函数的主要原因是用它替代复杂易错的宏函数。
- 编译器在编译阶段完成对inline函数的处理，也就是对inline函数的调用转换成函数的本体，但inline关键字对于编译器是一种建议，编译器可以这样做也可以不这样做，从逻辑上讲，编译器实现inline有这样几个步骤
  - 将inline函数体复制到函数调用的地方
  - 为函数内部的局部变量分配空间
  - 将输入参数和返回值映射到局部空间里
  - 如果有多个返回点，改成分支。

## 5. C++的类型转换

- 隐式转换
- 显示转换
- 新式转换

## 6. 内存对齐问题

## 7. 多线程了解吗？

## 8.如果C++中要使用C里面的函数有什么注意事项吗

## 9. malloc和new的区别？

- 

## 10. 堆栈的区别？为什么要用堆栈？

- 堆栈本身都是内存管理中对于内存的分配方式。
- 其中栈是由系统控制的，资源的释放是由系统自动执行，所以效率上较堆高。栈中放的一般有局部变量，函数的返回地址，返回值，寄存器状态等内容。
- 堆呢，是由用户控制的，用户使用malloc/new等进行内存的手动分配，由free/delete来实现内存的手动释放。

## 11. 内存管理的注意事项

## 12. Linux进程调度算法

## 13. Linux进程地址空间分布

## 14. Linux内存管理方法，页面置换算法，逻辑地址和物理地址的转换

## 15. 在一台内存为2G的机器上，malloc(20G)会怎么样？new 20G呢？

## 16. 进程和线程的区别，进程间通信方式

## 17. 孤儿进程，僵死进程，惊群效应

## 18. IO模型，Select，Epoll和Poll的区别

## 19.ET和LT的区别

## 20. TCP三次握手四次挥手状态图，对应的POSIX API，为什么要三次握手，两次可以吗？

## 21. TIME_WAIT的作用

## 22. TCP和UDP区别，TCP如何保证可靠性，对方是否存活(心跳检测)

## 23. 流量控制，拥塞控制

## 24. SYN Flood攻击

## 25. HTTP状态码

## 26. Libevent如何处理IO事件，信号事件，和定时事件

## 27. 布隆过滤器

## 28. 智能指针

## 29. hash表解决冲突的方法。

## 30. 红黑树的性质

## 31. redis中的数据结构

## 32. 跳表的插入和删除过程

## 33.  大数相加

## 34. LCS

## 35. 二叉树中两个节点的最近公共父节点

## 36. 数据流的中位数。

## 37. 虚函数的实现原理

## 38. 子类构造析构函数的调用顺序

## 39. Vector，List，Map底层实现原理

## 40. struct和union

## 41. C++11的新特性

## 42. B和B+树

## 43.ACID

## 44. 索引

## 45. https？ SSL 对称加密和非对称加密

## 46. 乐观锁 悲观锁 

## 47. TCP是如何实现可靠传输的。

## 48. 除了`std::weak_ptr`，还有哪些解决循环引用的办法？

## 49. 来实现一个`unique_ptr`吧，不需要自定义的deleter，简单的就可以

## 50 . C++从源文件到可执行文件的过程

## 51. 浏览器输入域名到显示页面的过程

## 52. Linux指令 查看进程状态？查看文件信息？查看内存使用？查看磁盘占有量？Grep指令的原理

## 53.软链接与硬链接的区别？ Linux怎么实现进程和线程的

## 54. 用户态与内核态的区别（用读文件举例说明

## 55. 根据王者荣耀段位（青铜，白银，etc.，每个段位人数非常庞大），设计一个系统，每个段位显示前1000名,每个人可以查看自己的排名

## 56.const修饰变量放在不同位置时的含义

## 57. 函数传参有哪几种方式

## 58. 是否可以返回局部变量的引用

## 59. 运行时多态的实现原理.

## 60. 内存泄漏的几种原因，循环引用是怎么回事

## 61. 智能指针有哪几种，各自有什么应用场景

## 62. 基类对象的指针转换为派生类对象的指针使用哪一个类型转换运算符

## 63.可执行程序由哪几个部分组成

## 64. 两个线程同时读写一个vector对象是否安全

## 65.1亿个文件，每个文件中有1亿个数字，找到最大的40个数字

## 66. 指针和引用的区别

## 67. 常量指针和常量引用的概念

## 68. 纯虚函数的作用

## 69. hash底层实现原理，碰撞解决方案

## 70.  进程有哪些状态，什么时候进入该状态

## 71.数据库索引底层用的是什么数据结构

## 72. 什么是大顶堆，给定无序数组如何建立大顶堆

## 73.epoll的实现原理，底层是什么数据结构

## 74.C++多态和模板偏特化的概念

## 75. 态库和静态库有什么区别，如何理解动态库的“与位置无关代码”的含义

## 76. 设计一个类，不允许生成栈上的对象

## 77.给定点分十进制的有效ip地址，转换为整数形式的ip地址

## 78. 申请10M栈空间可能出现的问题

## 79. 内存对齐的原理、内存对齐高效的原因、禁止内存对齐的方法

## 80. 如何用C实现面向对象

## 81. 是否可以用C实现多态

## 82. 贪心算法与动态规划算法的区别

## 83. TCP半连接攻击

## 84. 拉链法是否可优化，线性探测法如何确定给定元素是否存在



























































































