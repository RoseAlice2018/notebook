## 数据结构与算法-----二叉树

### 二叉树的存储

- 链式存储

```
template <class T>
struct TreeNode
{
	TreeNode* leftchild;
	TreeNode* rightchild;
	T data;
	TreeNode(T x)leftchild(NULL),rightchild(NULL),data(x){}
	~TreeNode();
};
```

- 顺序存储（用数组存储数组）

### 二叉树的遍历

#### 前序遍历

- 递归

  ```
  void preorder(TreeNode* root)
  {
  	if(root == NULL)
  		return;
  	cout<<root->value;
  	if(root->left)
  		preorder(root->left);
  	if(root->right)
  		preorder(root->right);
  }
  ```

  

- 非递归

  ```
  void preorder(TreeNode<int>* root)
  {
  	if(root == NULL)
  		return;
  	stack<TreeNode<int>*> T_pre;
  	T_pre.push(root);
      while(!T_pre.empty())
      {
          TreeNode<int>* temp=T_pre.top();
          T_pre.pop();
          cout<<temp->data;
          if(temp->rightchild)
              T_pre.push(temp->rightchild);
          if(temp->leftchild)
              T_pre.push(temp->leftchild);
      }
      return;
  }
  ```

  

#### 中序遍历

- 递归

  ```
  void inorder(TreeNode* root)
  {
  	if(root == NULL)
  		return;
  	if(root->left)
  		inorder(root->left);
  	cout<<root->value;
  	if(root->right)
  		inorder(root->value);
  }
  ```

  

- 非递归

  ```
  void inorder(TreeNode<int>* root)
   {
       	if(root == NULL)
  		    return;
  	    stack<TreeNode<int>*> T_pre;
  	    T_pre.push(root);
          do
          {
              while(root!=NULL)
              {
                  T_pre.push(root);
                  root = root->leftchild;
              }
              if(!T_pre.empty())
              {
                  TreeNode<int>* temp= T_pre.top();
                  T_pre.pop();
                  cout<<temp->data;
                  root = temp->rightchild;
              }
          } while (!T_pre.empty()||root!=NULL);
          return ;
   }
  ```

  

#### 后序遍历

- 递归

  ```
  void postorder(TreeNode* root)
  {
  	if(root == NULL)
  		return ;
  	if(root->left)
  		postorder(root->left);
  	if(root->right)
  		postorder(root->right);
  	cout<<root->data;
  }
  ```

  

- 非递归

  ```
   void postorder(TreeNode<int>* root)
   {
       if(root == NULL)
       {
           return ;
       }
       stack<TreeNode<int>*> T_post;
       stack<TreeNode<int>*> T;
       T_post.push(root);
       while(!T_post.empty())
       {
           TreeNode<int>* curr = T_post.top();
           T.push(curr);
           T_post.pop();
           if(curr->leftchild)
              T_post.push(curr->leftchild);
          if(curr->rightchild)
              T_post.push(curr->rightchild);
       }
       while(!T.empty())
       {
           cout<<T.top()->data<<endl;
           T.pop();
       }
   }
  ```

  

### 特殊二叉树

#### 满二叉树

#### 二叉查找树

#### 平衡查找树





