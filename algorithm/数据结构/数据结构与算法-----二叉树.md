## 数据结构与算法-----二叉树

[toc]



### 二叉树的存储

- 链式存储

```
template <class T>
struct TreeNode
{
	TreeNode* leftchild;
	TreeNode* rightchild;
	T data;
	TreeNode(T x)leftchild(NULL),rightchild(NULL),data(x){}
	~TreeNode();
};
```

- 顺序存储（用数组存储数组）

### 二叉树的深度优先遍历

#### 前序遍历

- 递归

  ```
  void preorder(TreeNode* root)
  {
  	if(root == NULL)
  		return;
  	cout<<root->value;
  	if(root->left)
  		preorder(root->left);
  	if(root->right)
  		preorder(root->right);
  }
  ```

  

- 非递归

  ```
  void preorder(TreeNode<int>* root)
  {
  	if(root == NULL)
  		return;
  	stack<TreeNode<int>*> T_pre;
  	T_pre.push(root);
      while(!T_pre.empty())
      {
          TreeNode<int>* temp=T_pre.top();
          T_pre.pop();
          cout<<temp->data;
          if(temp->rightchild)
              T_pre.push(temp->rightchild);
          if(temp->leftchild)
              T_pre.push(temp->leftchild);
      }
      return;
  }
  ```

  

#### 中序遍历

- 递归

  ```
  void inorder(TreeNode* root)
  {
  	if(root == NULL)
  		return;
  	if(root->left)
  		inorder(root->left);
  	cout<<root->value;
  	if(root->right)
  		inorder(root->value);
  }
  ```

  

- 非递归

  ```
  void inorder(TreeNode<int>* root)
   {
       	if(root == NULL)
  		    return;
  	    stack<TreeNode<int>*> T_pre;
  	    T_pre.push(root);
          do
          {
              while(root!=NULL)
              {
                  T_pre.push(root);
                  root = root->leftchild;
              }
              if(!T_pre.empty())
              {
                  TreeNode<int>* temp= T_pre.top();
                  T_pre.pop();
                  cout<<temp->data;
                  root = temp->rightchild;
              }
          } while (!T_pre.empty()||root!=NULL);
          return ;
   }
  ```

  

#### 后序遍历

- 递归

  ```
  void postorder(TreeNode* root)
  {
  	if(root == NULL)
  		return ;
  	if(root->left)
  		postorder(root->left);
  	if(root->right)
  		postorder(root->right);
  	cout<<root->data;
  }
  ```

  

- 非递归

  ```
   void postorder(TreeNode<int>* root)
   {
       if(root == NULL)
       {
           return ;
       }
       stack<TreeNode<int>*> T_post;
       stack<TreeNode<int>*> T;
       T_post.push(root);
       while(!T_post.empty())
       {
           TreeNode<int>* curr = T_post.top();
           T.push(curr);
           T_post.pop();
           if(curr->leftchild)
              T_post.push(curr->leftchild);
          if(curr->rightchild)
              T_post.push(curr->rightchild);
       }
       while(!T.empty())
       {
           cout<<T.top()->data<<endl;
           T.pop();
       }
   }
  ```

### 二叉树的广度优先遍历

#### 层次遍历

```
void level(TreeNode<int>* root)
 {
     if(root == NULL)
        return ;
    queue<TreeNode<int>*> temp;
    temp.push(root);
    while(!temp.empty())
    {
        TreeNode<int>* t=temp.front();
        temp.pop();
        if(t->leftchild)
            temp.push(t->leftchild);
        if(t->rightchild)
            temp.push(t->rightchild);
    }
 }
```

##### 例题：[leetcode 102](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) 

```
  struct TreeNode {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  };
 
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) 
    {
        vector<vector<int>> res;
        if(root == NULL)
            return res;
        queue<TreeNode*> t;
        vector<int> temp;
        t.push(root);
        while(!t.empty())
        {
            queue<TreeNode*> tt;
            while(!t.empty())
            {
                TreeNode* node=t.front();
                temp.push_back(node->val);
                if(node->left)
                    tt.push(node->left);
                if(node->right)
                    tt.push(node->right);
                t.pop();
            }
            res.push_back(temp);
            temp.clear();
            t=tt;
        }
        return res;
    }
};
```

- 更快一点

  ```
  class Solution {
  public:
      vector<vector<int>> levelOrder(TreeNode* root) {
          vector <vector <int>> ret;
          if (!root) {
              return ret;
          }
  
          queue <TreeNode*> q;
          q.push(root);
          while (!q.empty()) {
              int currentLevelSize = q.size();
              ret.push_back(vector <int> ());
              for (int i = 1; i <= currentLevelSize; ++i) {
                  auto node = q.front(); q.pop();
                  ret.back().push_back(node->val);
                  if (node->left) q.push(node->left);
                  if (node->right) q.push(node->right);
              }
          }
          
          return ret;
      }
  };
  
  作者：LeetCode-Solution
  链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/
  来源：力扣（LeetCode）
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
  ```

##### [例题：leetcode 107](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

  ```
  class Solution {
  public:
      vector<vector<int>> levelOrder(TreeNode* root) {
          vector <vector <int>> ret;
          if (!root) {
              return ret;
          }
  
          queue <TreeNode*> q;
          q.push(root);
          while (!q.empty()) {
              int currentLevelSize = q.size();
              ret.push_back(vector <int> ());
              for (int i = 1; i <= currentLevelSize; ++i) {
                  auto node = q.front(); q.pop();
                  ret.back().push_back(node->val);
                  if (node->left) q.push(node->left);
                  if (node->right) q.push(node->right);
              }
          }
          
         reverse(ret.begin(),ret.end());
         return ret;
      }
  };
  ```
##### [例题：leetcode 199](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) 
    {
        vector<int> res;
        if (!root) {
            return res;
        }
        queue <TreeNode*> q;
        q.push(root);
        while (!q.empty()) 
        {
            int currentLevelSize = q.size();
            for (int i = 1; i <= currentLevelSize; ++i) 
            {
                auto node = q.front(); q.pop();
                if(i==currentLevelSize)
                    res.push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
        }
        return res;
    }
};
```



##### [例题：leetcode 637](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

```
 struct TreeNode {
     int val;
     TreeNode*left;
     TreeNode *right;
     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 };

class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) 
    {
        vector<double> res;
        if(root == NULL)
            return res;
        queue<TreeNode*> t;
        t.push(root);
        while(!t.empty())
        {
            int currentszie = t.size();
            double sum=0;
            for(int i=1;i<=currentszie;i++)
            {
                auto temp=t.front();t.pop();
                sum+=temp->val;
                if(temp->left)
                    t.push(temp->left);
                if(temp->right)
                    t.push(temp->right);
            }
            res.push_back(sum/(double)currentszie);
        }
        return res;
    }
};
```
##### [例题：leetcode 429](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

```

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) 
    {
          vector<vector<int>> ret;
          if(!root)
            return ret;
          queue<Node*> t;
          t.push(root);
          while(!t.empty())  
          {
              vector<int> temp_ret;
              int currentsize = t.size();
              for(int i=1;i<=currentsize;i++)
              {
                  auto tt=t.front();t.pop();
                  temp_ret.push_back(tt->val);
                  if(!tt->children.empty())
                    {
                        for(int j=0;j<tt->children.size();j++)
                    t.push(tt->children[j]);
                    }
                  
              }
              ret.push_back(temp_ret);
          }
          return ret;
    }
};
```

### 二叉树相关例题总结

#### 求二叉树的属性

###### [二叉树: 是否对称](https://leetcode-cn.com/problems/symmetric-tree/)

```
  struct TreeNode {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  };
 
class Solution {
public:
    bool isSymmetric(TreeNode* root) 
    {
        if(root==NULL||((!root->left)&&(!root->right)))
            return true;
        else 
            return compare(root->left,root->right);
        return false;
    }
    bool compare(TreeNode* p,TreeNode* q)
    {
        if(p&&q)
        {
            if(p->val!=q->val)
                return false;
            return compare(p->left,q->right)&&compare(p->right,q->left);
        }
        else if((!p)&&(!q))
        {
           return true;
        }
        return false;
    }
};
```

- 递归的算法很容易可以想到,那么思考一下,怎样才能用递归去处理呢?

### 特殊二叉树

#### 满二叉树

#### 二叉查找树

#### 平衡查找树





